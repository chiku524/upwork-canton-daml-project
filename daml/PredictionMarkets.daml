module PredictionMarkets where

import DA.Finance.Asset
import DA.Finance.Types
import DA.Finance.Interface.Account
import DA.Finance.Interface.Holding
import DA.Finance.Interface.Settlement
import DA.Finance.Interface.Types.Common
import DA.Finance.Interface.Types.Token
import DA.Finance.Interface.Util
import DA.Set
import DA.Time
import DA.List
import DA.Optional
import DA.Text
import DA.Map
import DA.Assert

-- ============================================================================
-- Types and Data Models
-- ============================================================================

data MarketType = Binary | MultiOutcome
  deriving (Eq, Show)

data MarketStatus = PendingApproval | Active | Resolving | Settled
  deriving (Eq, Show)

data PositionType = Yes | No | Outcome Text
  deriving (Eq, Show)

data SettlementTrigger = TimeBased Time | EventBased Text | Manual
  deriving (Eq, Show)

type MarketId = Text
type PositionId = Text
type OracleData = Text

-- Market configuration
template MarketConfig
  with
    admin : Party
    marketCreationDeposit : Decimal
    marketCreationFee : Decimal
    positionChangeFee : Decimal
    partialCloseFee : Decimal
    settlementFee : Decimal
    oracleParty : Party
    stablecoinCid : ContractId Token
  where
    signatory admin
    key admin : Party
    maintainer key

    choice UpdateFees : ContractId MarketConfig
      with
        newMarketCreationFee : Decimal
        newPositionChangeFee : Decimal
        newPartialCloseFee : Decimal
        newSettlementFee : Decimal
      controller admin
      do
        create this with
          marketCreationFee = newMarketCreationFee
          positionChangeFee = newPositionChangeFee
          partialCloseFee = newPartialCloseFee
          settlementFee = newSettlementFee

-- Market creation request (pending admin approval)
template MarketCreationRequest
  with
    creator : Party
    admin : Party
    marketId : MarketId
    title : Text
    description : Text
    marketType : MarketType
    outcomes : [Text]  -- For multi-outcome markets
    settlementTrigger : SettlementTrigger
    resolutionCriteria : Text  -- Description of how market resolves
    depositAmount : Decimal
    depositCid : ContractId Holding
    configCid : ContractId MarketConfig
    creatorAccount : Account
    adminAccount : Account
  where
    signatory creator, admin
    key marketId : MarketId
    maintainer key

    choice ApproveMarket : ContractId Market
      controller admin
      do
        config <- fetch configCid
        deposit <- fetch depositCid
        currentTime <- getTime
        
        -- Calculate fee
        feeAmount = if config.marketCreationFee > 0.0
          then config.marketCreationFee
          else 0.0
        
        returnAmount = depositAmount - feeAmount
        
        -- If fee exists, transfer to admin account
        -- Note: This is simplified - proper implementation would use Settlement interface
        -- For now, we'll just create the market and handle fee separately
        
        -- Create the market
        marketCid <- create Market with
          marketId = marketId
          creator = creator
          admin = config.admin
          title = title
          description = description
          marketType = marketType
          outcomes = outcomes
          settlementTrigger = settlementTrigger
          resolutionCriteria = resolutionCriteria
          status = Active
          totalVolume = 0.0
          yesVolume = 0.0
          noVolume = 0.0
          outcomeVolumes = fromList []
          positions = fromList []
          resolutionData = None
          resolvedOutcome = None
          settlementStep = 0
          createdAt = currentTime
          configCid = configCid
        
        -- Return deposit (would need proper account transfer in production)
        -- For now, the deposit holding remains and can be returned via separate choice
        
        return marketCid

    choice RejectMarket : ()
      controller admin
      do
        -- Archive the request - deposit can be returned via separate mechanism
        return ()

-- Core Market template
template Market
  with
    marketId : MarketId
    creator : Party
    admin : Party
    title : Text
    description : Text
    marketType : MarketType
    outcomes : [Text]
    settlementTrigger : SettlementTrigger
    resolutionCriteria : Text
    status : MarketStatus
    totalVolume : Decimal
    yesVolume : Decimal
    noVolume : Decimal
    outcomeVolumes : Map Text Decimal
    positions : Map PositionId (ContractId Position)
    resolutionData : Optional OracleData
    resolvedOutcome : Optional Text
    settlementStep : Int
    createdAt : Time
    configCid : ContractId MarketConfig
  where
    signatory creator, admin
    key marketId : MarketId
    maintainer key

    -- Viewers: creator and admin can see market, participants see aggregated data
    controller creator, admin can
      nonconsuming GetMarketState : Market
        do return this

    -- Create a new position (buy)
    -- Any party can create positions in active markets
    choice CreatePosition : ContractId Position
      with
        positionId : PositionId
        owner : Party
        positionType : PositionType
        amount : Decimal
        price : Decimal  -- Price per share (0.0 to 1.0)
      controller owner
      do
        assert_ (status == Active) "Market must be active to create positions"
        
        config <- fetch configCid
        
        -- Calculate fees
        feeAmount = if config.positionChangeFee > 0.0
          then amount * config.positionChangeFee
          else 0.0
        
        -- Validate position type matches market type
        validPosition <- case (marketType, positionType) of
          (Binary, Yes) -> pure True
          (Binary, No) -> pure True
          (MultiOutcome, Outcome outcome) -> pure (outcome `elem` outcomes)
          _ -> pure False
        
        assert_ validPosition "Invalid position type for market"
        
        currentTime <- getTime
        
        -- Create position contract
        positionCid <- create Position with
          positionId = positionId
          marketId = marketId
          owner = owner
          positionType = positionType
          amount = amount
          price = price
          createdAt = currentTime
        
        -- Update market volumes
        updatedYesVolume = if positionType == Yes
          then yesVolume + amount
          else yesVolume
        
        updatedNoVolume = if positionType == No
          then noVolume + amount
          else noVolume
        
        updatedOutcomeVolumes = case positionType of
          Outcome outcome -> 
            let currentVolume = case lookup outcome outcomeVolumes of
                  Some vol -> vol
                  None -> 0.0
            in insert outcome (currentVolume + amount) outcomeVolumes
          _ -> outcomeVolumes
        
        -- Update market state
        create this with
          totalVolume = totalVolume + amount
          yesVolume = updatedYesVolume
          noVolume = updatedNoVolume
          outcomeVolumes = updatedOutcomeVolumes
          positions = insert positionId positionCid positions

    -- Update position (adjust size)
    choice UpdatePosition : ContractId Market
      with
        positionId : PositionId
        newAmount : Decimal
        newPrice : Decimal
      controller creator, admin
      do
        assert_ (status == Active) "Market must be active to update positions"
        
        positionCid <- case lookup positionId positions of
          Some cid -> pure cid
          None -> abort "Position not found"
        
        position <- fetch positionCid
        
        config <- fetch configCid
        
        -- Calculate fee on the change
        changeAmount = abs (newAmount - position.amount)
        feeAmount = if config.positionChangeFee > 0.0
          then changeAmount * config.positionChangeFee
          else 0.0
        
        -- Update position
        _ <- exercise positionCid UpdatePositionAmount with
          newAmount = newAmount
          newPrice = newPrice
        
        -- Update market volumes
        oldAmount = position.amount
        amountDiff = newAmount - oldAmount
        
        updatedYesVolume = if position.positionType == Yes
          then yesVolume + amountDiff
          else yesVolume
        
        updatedNoVolume = if position.positionType == No
          then noVolume + amountDiff
          else noVolume
        
        updatedOutcomeVolumes = case position.positionType of
          Outcome outcome -> 
            let currentVolume = case lookup outcome outcomeVolumes of
                  Some vol -> vol
                  None -> 0.0
            in insert outcome (currentVolume + amountDiff) outcomeVolumes
          _ -> outcomeVolumes
        
        create this with
          totalVolume = totalVolume + amountDiff
          yesVolume = updatedYesVolume
          noVolume = updatedNoVolume
          outcomeVolumes = updatedOutcomeVolumes

    -- Partial close position
    choice PartialClosePosition : ContractId Market
      with
        positionId : PositionId
        closeAmount : Decimal
      controller creator, admin
      do
        assert_ (status == Active) "Market must be active to close positions"
        
        positionCid <- case lookup positionId positions of
          Some cid -> pure cid
          None -> abort "Position not found"
        
        position <- fetch positionCid
        assert_ (closeAmount <= position.amount) "Cannot close more than position amount"
        
        config <- fetch configCid
        
        -- Calculate fee
        feeAmount = if config.partialCloseFee > 0.0
          then closeAmount * config.partialCloseFee
          else 0.0
        
        -- Update position
        newAmount = position.amount - closeAmount
        _ <- if newAmount > 0.0
          then exercise positionCid UpdatePositionAmount with
            newAmount = newAmount
            newPrice = position.price
          else exercise positionCid Archive
        
        -- Update market volumes
        updatedYesVolume = if position.positionType == Yes
          then yesVolume - closeAmount
          else yesVolume
        
        updatedNoVolume = if position.positionType == No
          then noVolume - closeAmount
          else noVolume
        
        updatedOutcomeVolumes = case position.positionType of
          Outcome outcome -> 
            let currentVolume = case lookup outcome outcomeVolumes of
                  Some vol -> vol
                  None -> 0.0
            in insert outcome (currentVolume - closeAmount) outcomeVolumes
          _ -> outcomeVolumes
        
        create this with
          totalVolume = totalVolume - closeAmount
          yesVolume = updatedYesVolume
          noVolume = updatedNoVolume
          outcomeVolumes = updatedOutcomeVolumes

    -- Start resolution (Step 1: Trigger resolution)
    choice StartResolution : ContractId Market
      with
        oracleData : OracleData
      controller admin
      do
        assert_ (status == Active) "Market must be active to start resolution"
        
        -- Check if trigger condition is met
        currentTime <- getTime
        triggerMet = case settlementTrigger of
          TimeBased triggerTime -> currentTime >= triggerTime
          EventBased _ -> True  -- Oracle data indicates event occurred
          Manual -> True
        
        assert_ triggerMet "Settlement trigger condition not met"
        
        create this with
          status = Resolving
          resolutionData = Some oracleData
          settlementStep = 1

    -- Resolve outcome (Step 2: Determine winning outcome)
    choice ResolveOutcome : ContractId Market
      with
        outcome : Text
      controller admin
      do
        assert_ (status == Resolving) "Market must be in resolving state"
        assert_ (settlementStep == 1) "Must be at resolution step"
        
        -- Validate outcome
        validOutcome = case marketType of
          Binary -> outcome == "Yes" || outcome == "No"
          MultiOutcome -> outcome `elem` outcomes
        
        assert_ validOutcome "Invalid outcome for market type"
        
        create this with
          resolvedOutcome = Some outcome
          settlementStep = 2

    -- Execute settlement (Step 3: Transfer winnings)
    choice ExecuteSettlement : ContractId Market
      controller admin
      do
        assert_ (status == Resolving) "Market must be in resolving state"
        assert_ (settlementStep == 2) "Must be at settlement step"
        
        resolved <- case resolvedOutcome of
          Some outcome -> pure outcome
          None -> abort "Outcome must be resolved before settlement"
        
        config <- fetch configCid
        
        -- Settlement logic: Calculate payouts for each position
        -- This is simplified - in production would iterate through positions
        -- and transfer stablecoin based on outcome
        -- For now, we mark as settled - actual transfers would happen via Settlement interface
        
        create this with
          status = Settled
          settlementStep = 3

    -- Admin override for disputes
    choice AdminOverride : ContractId Market
      with
        newStatus : MarketStatus
        newOutcome : Optional Text
      controller admin
      do
        create this with
          status = newStatus
          resolvedOutcome = newOutcome

-- Position template (private to owner)
template Position
  with
    positionId : PositionId
    marketId : MarketId
    owner : Party
    positionType : PositionType
    amount : Decimal
    price : Decimal
    createdAt : Time
  where
    signatory owner
    key (positionId, owner) : (PositionId, Party)
    maintainer key

    -- Only owner can view their position
    controller owner can
      nonconsuming GetPosition : Position
        do return this

    choice UpdatePositionAmount : ContractId Position
      with
        newAmount : Decimal
        newPrice : Decimal
      controller owner
      do
        assert_ (newAmount >= 0.0) "Amount must be non-negative"
        create this with
          amount = newAmount
          price = newPrice

    choice Archive : ()
      controller owner
      do return ()

-- Oracle data feed template
template OracleDataFeed
  with
    oracleParty : Party
    marketId : MarketId
    dataSource : Text
    data : OracleData
    timestamp : Time
    signature : Optional Text  -- For oracle signature verification
  where
    signatory oracleParty
    key (marketId, timestamp) : (MarketId, Time)
    maintainer key

    choice UpdateData : ContractId OracleDataFeed
      with
        newData : OracleData
        newTimestamp : Time
        newSignature : Optional Text
      controller oracleParty
      do
        create this with
          data = newData
          timestamp = newTimestamp
          signature = newSignature

